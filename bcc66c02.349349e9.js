(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{109:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return a})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return d}));var r=n(3),o=n(7),i=(n(0),n(127)),a={id:"ssr",title:"Server-Side Rendering"},s={unversionedId:"ssr",id:"ssr",isDocsHomePage:!1,title:"Server-Side Rendering",description:"Remotion's rendering engine is built upon Node.JS, which makes it exceptionally easy to render a video in the cloud.",source:"@site/docs/ssr.md",slug:"/ssr",permalink:"/docs/ssr",editUrl:"https://github.com/JonnyBurger/remotion/edit/main/packages/docs/docs/ssr.md",version:"current",sidebar:"someSidebar",previous:{title:"Parametrized rendering",permalink:"/docs/parametrized-rendering"},next:{title:"Importing assets",permalink:"/docs/assets"}},l=[{value:"Render a video programmatically",id:"render-a-video-programmatically",children:[]},{value:"Render using a HTTP server",id:"render-using-a-http-server",children:[]},{value:"Render using a HTTP server (Dockerized)",id:"render-using-a-http-server-dockerized",children:[]},{value:"Render using GitHub Actions",id:"render-using-github-actions",children:[]}],c={toc:l};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Remotion's rendering engine is built upon Node.JS, which makes it exceptionally easy to render a video in the cloud."),Object(i.b)("p",null,"Since Remotion is built with tech (",Object(i.b)("em",{parentName:"p"},"Node.JS, FFMPEG, Puppeteer"),") that works well cross-platform, you can without much hassle run it on a Linux-based system or even dockerize your video."),Object(i.b)("p",null,"On this page, we demonstrate the server-rendering capabilities or Remotion using examples ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"/docs#installation"}),"built into the template"),"!"),Object(i.b)("h2",{id:"render-a-video-programmatically"},"Render a video programmatically"),Object(i.b)("p",null,"The NPM package ",Object(i.b)("inlineCode",{parentName:"p"},"@remotion/renderer")," provides you with an API for rendering the videos programmatically. You can make a video in three steps: creating a Webpack bundle, rendering the frames, and stitching them together to an MP4. This gives you more independence and allows you to for example skip the stitching process, if you just want a PNG sequence."),Object(i.b)("p",null,"Follow this commented example to see how to render a video:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-tsx"}),"import fs from 'fs';\nimport {evaluateRootForCompositions} from 'remotion';\nimport {bundle} from '@remotion/bundler';\nimport {\n    getCompositions,\n    renderFrames,\n    stitchFramesToVideo,\n} from '@remotion/renderer';\n\nconst start = async () => {\n  // The composition you want to render\n  const compositionId = 'HelloWorld';\n\n  // Create a webpack bundle of the entry file.\n  const bundled = await bundle(require.resolve('./src/index'));\n\n  // Extract all the compositions you have defined in your project\n  // from the webpack bundle.\n  const comps = await getCompositions(bundled);\n\n  // Select the composition you want to render.\n  const video = comps.find((c) => c.id === compositionId);\n\n  // We create a temporary directory for storing the frames\n  const framesDir = await fs.promises.mkdtemp(\n    path.join(os.tmpdir(), 'remotion-')\n  );\n\n  // We create PNGs for all frames\n  await renderFrames({\n    config: video,\n    // Path of the webpack bundle you have created\n    webpackBundle: bundled,\n    // Get's called after bundling is finished and the\n    // actual rendering starts.\n    onStart: () => console.log('Rendering frames...'),\n    onFrameUpdate: (f) => {\n      // Log a message whenever 10 frames have rendered.\n      if (f % 10 === 0) {\n        console.log(`Rendered frame ${f}`);\n      }\n    },\n    // How many CPU threads to use. `null` will use a sane default (half of the available threads)\n    // See 'CLI options' section for concurrency options.\n    parallelism: null,\n    outputDir: framesDir,\n    // React props passed to the root component of the sequence. Will be merged with the `defaultProps` of a video.\n    userProps: {\n      titleText: 'Hello World'\n    },\n    compositionId,\n    // Can be either 'jpeg' or 'png'. JPEG is faster, but has no transparency.\n    imageFormat: 'jpeg'\n  });\n\n  // Add this step if you want to make an MP4 out of the rendered frames.\n  await stitchFramesToVideo({\n    // Input directory of the frames\n    dir: tmpDir,\n    // Overwrite existing video\n    force: true,\n    // Possible overwrite of video metadata,\n    // we suggest to just fill in the data from the\n    // video variable\n    fps: video.fps,\n    height: video.height,\n    width: video.width,\n    // Must match the value above for the image format\n    imageFormat: 'jpeg',\n    // Pass in the desired output path of the video. Et voil\xe0!\n    outputLocation: path.join(tmpDir, 'out.mp4'),\n    // FFMPEG pixel format\n    pixelFormat: 'yuv420p',\n    // Hook into the FFMPEG progress\n    onProgress: (frame) => void 0\n  });\n};\n\nstart();\n")),Object(i.b)("p",null,Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"parametrized-rendering#passing-props-in-github-actions"}),"See also: Passing props in GitHub Actions")),Object(i.b)("h2",{id:"render-using-a-http-server"},"Render using a HTTP server"),Object(i.b)("p",null,"In the ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"/docs#installation"}),"template"),", we added a minimal example of an HTTP server that dynamically returns a video whenever you call the URL."),Object(i.b)("p",null,"The server is located under ",Object(i.b)("inlineCode",{parentName:"p"},"server.tsx"),", and you can run it using ",Object(i.b)("inlineCode",{parentName:"p"},"npm run server"),". Call the default URL with parameters, and it will return a video after some time! Try it out in the browser or using cURL:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-bash"}),'curl "http://localhost:8000?titleText=Hello,+World!&titleColor=red" > output.mp4\n')),Object(i.b)("p",null,"Note that we only added a minimal example. For production, you should consider adding a queueing system and rate limiting."),Object(i.b)("h2",{id:"render-using-a-http-server-dockerized"},"Render using a HTTP server (Dockerized)"),Object(i.b)("p",null,"We added a Dockerfile that includes FFMPEG and added it to the template. That means you can also run the server described in the section above using Docker."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-bash"}),"docker build -t my-video .\ndocker run -p 8000:8000 --privileged my-video\n")),Object(i.b)("h2",{id:"render-using-github-actions"},"Render using GitHub Actions"),Object(i.b)("p",null,"The template includes a GitHub Actions workflow file\nunder ",Object(i.b)("inlineCode",{parentName:"p"},".github/workflows/render-video.yml"),". All you have to do is to adjust the props that your root component accepts in the workflow file and you can render a video right on GitHub."),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Commit the template to a GitHub repository"),Object(i.b)("li",{parentName:"ol"},"On GitHub, click the 'Actions' tab."),Object(i.b)("li",{parentName:"ol"},"Select the 'Render video' workflow on the left."),Object(i.b)("li",{parentName:"ol"},"A 'Run workflow' button should appear. Click it"),Object(i.b)("li",{parentName:"ol"},"Fill in the props of the root component and click 'Run workflow'."),Object(i.b)("li",{parentName:"ol"},"After the rendering is finished, you can download the video under 'Artifacts'.")),Object(i.b)("p",null,"Note that running the workflow may incur costs. However, the workflow will only run if you actively trigger it."),Object(i.b)("p",null,Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"parametrized-rendering#passing-props-in-github-actions"}),"See also: Passing props in GitHub Actions")))}d.isMDXComponent=!0},127:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return b}));var r=n(0),o=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=o.a.createContext({}),d=function(e){var t=o.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=d(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,a=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(n),m=r,b=p["".concat(a,".").concat(m)]||p[m]||u[m]||i;return n?o.a.createElement(b,s(s({ref:t},c),{},{components:n})):o.a.createElement(b,s({ref:t},c))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var c=2;c<i;c++)a[c]=n[c];return o.a.createElement.apply(null,a)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);