---
image: /generated/articles-docs-validating-user-videos.png
id: validating-user-videos
title: Validating user videos
crumb: 'Building video apps'
---

When building an app that accepts user video uploads, you should validate whether the browser can decode the video before uploading it. This saves bandwidth, provides immediate feedback to the user, and reduces unnecessary server processing.

## Checking video compatibility

Use Remotion's [canDecode()](/docs/mediabunny/can-decode) snippet based on [Mediabunny](/docs/mediabunny) to check if a video can be decoded by the browser.

The `canDecode()` function checks if a video can be played in the browser and loaded into [`<Video>`](/docs/media/video) from `@remotion/media`.

:::note
Different Remotion video components have different format compatibilities:

- **[`<Video>`](/docs/media/video)**: Mediabunny-based custom video tag with broad format support
- **[`<Html5Video>`](/docs/html5-video)**: Uses browser's native decoding using `<video>` element
- **[`<OffthreadVideo>`](/docs/offthreadvideo)**: Supports more formats during rendering, uses `<Html5Video>` for preview in the Player and Studio

Learn more about the supported media formats: [Video formats](/docs/miscellaneous/video-formats)
:::

## Validation example in React

:::note
This is a simplified example showing the validation flow. In a real application, the implementation will vary depending on your upload strategy (direct upload, presigned URLs, multipart uploads, etc.) and where you store videos (S3, GCS, your own server, etc.).
:::

```tsx twoslash title="ValidatedUploader.tsx"
const canDecode = async (src: string) => {
  return true;
};
const upload = async (file: File) => {
  return 'https://example.com/video.mp4';
};
// ---cut---
import {useCallback, useState} from 'react';

type UploadState = {type: 'idle'} | {type: 'validating'} | {type: 'uploading'} | {type: 'ready'; url: string} | {type: 'error'; message: string};

export const ValidatedUploader: React.FC = () => {
  const [state, setState] = useState<UploadState>({type: 'idle'});

  const handleUpload = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    try {
      setState({type: 'validating'});
      const blobUrl = URL.createObjectURL(file);
      const isCompatible = await canDecode(blobUrl);
      URL.revokeObjectURL(blobUrl);

      if (!isCompatible) {
        setState({
          type: 'error',
          message: 'Video format not supported. Please use MP4 (H.264/AAC).',
        });
        return;
      }

      setState({type: 'uploading'});
      const url = await upload(file);
      setState({type: 'ready', url});
    } catch (error) {
      setState({type: 'error', message: 'Failed to process video'});
    }
  }, []);

  return (
    <div>
      <input type="file" accept="video/*" onChange={handleUpload} />
      {state.type === 'error' && <p>{state.message}</p>}
      {state.type === 'ready' && <p>Video ready: {state.url}</p>}
    </div>
  );
};
```

## Handling incompatible videos

When a video cannot be decoded, you have two options:

### 1. Reject with clear instructions (Recommended)

Show a clear error message telling users what format is required (see example above).

### 2. Re-encode on the backend

If you need to accept videos in any format, you'll need to re-encode incompatible videos on your backend. This is a complex undertaking that requires:

- **FFmpeg infrastructure** with proper resource limits and monitoring
- **Job queueing system** to handle concurrent uploads without overloading servers
- **Progress tracking** to inform users about re-encoding status
- **File size validation** and limits to prevent abuse
- **Smart codec handling** - only re-encode incompatible streams (e.g., if video codec is compatible but audio is not, copy the video stream and re-encode only the audio to preserve quality)
- **Error handling and retry logic** for failed conversions
- **Storage management** for temporary files during processing

Building a production-grade video re-encoding pipeline is complex and requires significant infrastructure. Consider using cloud transcoding services (AWS MediaConvert, Google Transcoder API, Cloudflare Stream, Mux Video) instead of building your own.

## See also

- [Handling user video uploads](/docs/video-uploads)
- [Uploading with presigned URLs](/docs/presigned-urls)
- [Video formats](/docs/miscellaneous/video-formats)
- [Check if video can be decoded](/docs/mediabunny/can-decode)
- [Mediabunny Documentation](https://mediabunny.dev)
