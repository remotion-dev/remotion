---
image: /generated/articles-docs-ai-dynamic-compilation.png
crumb: 'AI'
title: Dynamic Compilation
sidebar_label: Dynamic Compilation
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This guide shows how to take Remotion code (a string) and compile it in the browser to display a live preview. No server round-trip required.

## The Goal

When building a Lovable-style tool for animations and motion graphics, users submit a prompt, receive AI-generated code, and want to see their animation immediately. Building a sandboxing environment is an option, but it adds overhead for previewing a single React component.

In this guide, you will learn how to leverage dynamic compilation of the code right within the browser to get a Remotion Preview of the component.

If you followed the guide in [Code Generation](/docs/ai/generate), you will have Remotion code like the following:

```ts
const generatedCode = `
import { useCurrentFrame, AbsoluteFill } from "remotion";

export const MyComposition = () => {
  const frame = useCurrentFrame();
  return (
    <AbsoluteFill style={{ backgroundColor: "white", justifyContent: "center", alignItems: "center" }}>
      <div style={{ fontSize: 100 }}>{**/some animation/**}</div>
    </AbsoluteFill>
  );
};
`;
```

Thinking of the compilation as just a hook, the usage looks like this:

```tsx
import {Player} from '@remotion/player';
import {useCompilation} from './useCompilation';

export const Preview: React.FC<{code: string}> = ({code}) => {
  const {Component} = useCompilation(code);

  return <Player component={Component} durationInFrames={150} fps={30} compositionWidth={1920} compositionHeight={1080} />;
};
```

The rest of this page explains what happens behind the scenes to make a hook like `useCompilation` work.

## Installation

```bash
npm install @babel/standalone remotion @remotion/player
```

`@babel/standalone` runs Babel entirely in the browser:

- Transpiles JSX syntax (`<div>`) into `React.createElement()` calls
- Strips TypeScript type annotations so the code can run as plain JavaScript
- No build server or bundler required - everything happens client-side

## What Does Compilation Mean?

During typical development, your code exists as files on disk. When you run `npm run dev`, Vite or Webpack runs a dev server that reads those files, transforms JSX/TypeScript, and serves the compiled JavaScript to your browser. Similarly, `npm run build` pre-compiles everything into static files that can be deployed. In both cases, the transformation happens before the browser ever sees the code.

With AI-generated code, there are no files - the code is created dynamically in response to a user prompt. By the time it exists, you're already in the browser. So Babel needs to run client-side to do the same JSX/TypeScript transformation that would normally happen during dev or build.

**Example: What is the Babel output?**

Before (JSX + TypeScript):

```tsx
const MyComponent: React.FC = () => {
  return <div style={{color: 'red'}}>Hello</div>;
};
```

After (plain JavaScript):

```js
const MyComponent = () => {
  return React.createElement('div', {style: {color: 'red'}}, 'Hello');
};
```

The JSX syntax is converted to `React.createElement()` calls, and type annotations are stripped. This is valid JavaScript that browsers can understand - but the string still needs to be turned into actual executable code.

## The Core Idea

Let's start with the simplest possible case - a component with no imports, just pure JSX:

```tsx
const code = `
const MyComponent = () => {
  return <div style={{fontSize: 100}}>Hello</div>;
};
`;
```

To make this executable, two steps are required:

**Step 1: Transpile JSX with Babel**

```tsx
import * as Babel from '@babel/standalone';

const transpiled = Babel.transform(code, {
  presets: ['react', 'typescript'],
});

// Result: const MyComponent = () => { return React.createElement("div", ...); };
```

**Step 2: Execute the code and extract the component**

After transpilation, the result is this string:

```js
'const MyComponent = () => { return React.createElement("div", {style: {fontSize: 100}}, "Hello"); };';
```

But it's still just a string - not executable code. JavaScript's `Function` constructor turns it into a real function:

```tsx
const createComponent = new Function(
  'React', // Parameter: React will be available inside
  `${transpiled.code}\nreturn MyComponent;`, // Body: define component, then return it
);
```

This creates a function equivalent to:

```tsx
function createComponent(React) {
  const MyComponent = () => { return React.createElement("div", ...); };
  return MyComponent;
}
```

Calling this function and passing the actual React library makes the component available. The component code is wrapped inside, and dependencies (in this case just React) are passed in as arguments.

```tsx
const Component = createComponent(React);
// Component is now a real React component we can render!
```

<details>
<summary>That was too fast/shallow, how does it work exactly?</summary>

The `Function` constructor in JavaScript creates a new function from strings. The syntax is:

```tsx
new Function(param1, param2, ..., functionBody)
```

A simple example:

```tsx
const add = new Function('a', 'b', 'return a + b;');
add(2, 3); // Returns 5
```

The first arguments become parameter names, and the last argument is the function body as a string.

For this use case:

- `'React'` is passed as a parameter name, so `React` becomes available inside the function body
- The function body contains the transpiled component code plus `return MyComponent;`
- When `createComponent(React)` is called, the actual React library gets bound to the `React` variable

The key insight: `React` inside the transpiled code refers to whatever we pass in when calling the function.

</details>

## Adding Remotion APIs

Just React won't be enough for animations. Remotion components need access to APIs like `useCurrentFrame` and `AbsoluteFill`. These are injected the same way.

:::info
To make in-browser dynamic compilation work, all libraries used within the animation code must be passed in. Since not all of them are known upfront, you can provide a broad range of libraries to support most use cases.
:::

Think of it like the following - this is just a handful, but it gives you the right idea:

```tsx
import {AbsoluteFill, useCurrentFrame, spring} from 'remotion';

const createComponent = new Function('React', 'AbsoluteFill', 'useCurrentFrame', 'spring', `${transpiled.code}\nreturn MyComponent;`);

const Component = createComponent(React, AbsoluteFill, useCurrentFrame, spring);
```

Each parameter name becomes an available variable inside the executed code.

## Handling Import Statements

AI-generated code typically includes import statements. Since APIs are injected manually via the Function constructor, these imports need to be stripped:

```tsx
// AI generates this:
import {useCurrentFrame, AbsoluteFill} from 'remotion';

export const MyComposition = () => {
  const frame = useCurrentFrame();
  return <AbsoluteFill>...</AbsoluteFill>;
};
```

The imports are removed and just the component body is extracted:

```tsx
// Step 1: Remove imports (these are injected manually)
const codeWithoutImports = code.replace(/^import\s+.*$/gm, '').trim();

// Step 2: Extract component body from "export const X = () => { ... };"
const match = codeWithoutImports.match(/export\s+const\s+\w+\s*=\s*\(\s*\)\s*=>\s*\{([\s\S]*)\};?\s*$/);
const componentBody = match ? match[1].trim() : codeWithoutImports;

// Step 3: Wrap it back into a component
const wrappedSource = `const DynamicComponent = () => {\n${componentBody}\n};`;
```

## Complete Implementation

<Tabs>
<TabItem value="preview" label="Preview.tsx">

```tsx twoslash title="Preview.tsx"
// @noErrors
import {Player} from '@remotion/player';
import {useCompilation} from './useCompilation';

export const Preview: React.FC<{code: string}> = ({code}) => {
  const {Component, error} = useCompilation(code);

  if (error) {
    return <div style={{color: 'red'}}>Error: {error}</div>;
  }

  if (!Component) {
    return null;
  }

  return <Player component={Component} durationInFrames={150} fps={30} compositionWidth={1920} compositionHeight={1080} controls />;
};
```

</TabItem>
<TabItem value="hook" label="useCompilation.ts" default>

```tsx twoslash title="useCompilation.ts"
import * as Babel from '@babel/standalone';
import React, {useMemo} from 'react';
import {AbsoluteFill, useCurrentFrame, useVideoConfig, spring, interpolate, Sequence} from 'remotion';

interface CompilationResult {
  Component: React.ComponentType | null;
  error: string | null;
}

export function useCompilation(code: string): CompilationResult {
  return useMemo(() => {
    if (!code?.trim()) {
      return {Component: null, error: null};
    }

    try {
      // Strip imports and extract component body
      const codeWithoutImports = code.replace(/^import\s+.*$/gm, '').trim();
      const match = codeWithoutImports.match(/export\s+const\s+\w+\s*=\s*\(\s*\)\s*=>\s*\{([\s\S]*)\};?\s*$/);
      const componentBody = match ? match[1].trim() : codeWithoutImports;
      const wrappedSource = `const DynamicComponent = () => {\n${componentBody}\n};`;

      // Transpile JSX/TypeScript
      const transpiled = Babel.transform(wrappedSource, {
        presets: ['react', 'typescript'],
        filename: 'dynamic.tsx',
      });

      if (!transpiled.code) {
        return {Component: null, error: 'Transpilation failed'};
      }

      // Create component with injected APIs
      const createComponent = new Function('React', 'AbsoluteFill', 'useCurrentFrame', 'useVideoConfig', 'spring', 'interpolate', 'Sequence', `${transpiled.code}\nreturn DynamicComponent;`);

      const Component = createComponent(React, AbsoluteFill, useCurrentFrame, useVideoConfig, spring, interpolate, Sequence);

      return {Component, error: null};
    } catch (error) {
      return {
        Component: null,
        error: error instanceof Error ? error.message : 'Unknown compilation error',
      };
    }
  }, [code]);
}
```

</TabItem>
<TabItem value="generated" label="AI-Generated Code">

```ts title="Example AI Output"
const generatedCode = `import {useCurrentFrame, AbsoluteFill, spring, useVideoConfig} from 'remotion';

export const MyComposition = () => {
  const frame = useCurrentFrame();
  const {fps} = useVideoConfig();

  const scale = spring({
    frame,
    fps,
    config: {damping: 10, stiffness: 100},
  });

  return (
    <AbsoluteFill
      style={{
        backgroundColor: '#0f0f0f',
        justifyContent: 'center',
        alignItems: 'center',
      }}
    >
      <div
        style={{
          fontSize: 120,
          color: 'white',
          transform: \`scale(\${scale})\`,
        }}
      >
        Hello World
      </div>
    </AbsoluteFill>
  );
};`;
```

</TabItem>
</Tabs>

## Security Considerations

Dynamic code execution carries inherent risks. The AI-generated code runs with full access to the browser context.

For production applications, consider:

- **iframe isolation** - Run the Player in a sandboxed iframe
- **Web Worker compilation** - Move Babel transpilation to a worker
- **Content Security Policy** - Restrict what the generated code can access
- **Code validation** - Check for potentially harmful patterns before compilation

## See Also

For a ready for use implementation of the Dynamic Compilation and more, see the [Prompt to Motion Graphics template](https://github.com/remotion-dev/remotion/tree/main/packages/template-prompt-to-motion-graphics):

```bash
npx create-video@latest --prompt-to-motion-graphics
```

- [Code Generation](/docs/ai/generate) - How to generate Remotion code with AI
- [Player](/docs/player) - Remotion Player documentation
- [System Prompt](/docs/ai/system-prompt) - Teaching LLMs about Remotion
