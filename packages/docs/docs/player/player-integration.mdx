---
image: /generated/articles-docs-player-player-integration.png
id: integration
title: 'Code sharing'
crumb: '@remotion/player'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

If you are using the player, a common desire is to share the code with your Remotion Studio and/or server-side rendering. With the correct setup, you can write the component once and use it for previewing, displaying and rendering.

:::note
Remotion and your React app use a different Webpack config. Therefore, if you want to override your [Webpack configuration](/docs/webpack), you need to override both the Remotion one and the React app one.
:::

## Template

Use one of our starter templates:

- [Next.js (App dir)](/templates/next)
- [Next.js (App dir + TailwindCSS)](/templates/next-tailwind)
- [Next.js (Pages dir)](/templates/next-pages-dir)
- [React Router 7 (Remix)](/templates/react-router)

which have the Player and Lambda already set up.

## Manual setup

Set up a React project with your preferred setup from the [Official React docs](https://react.dev/learn/start-a-new-react-project). Popular choices are:

- [Next.js](https://nextjs.org/learn/basics/create-nextjs-app/setup)
- [React Router](https://reactrouter.com/start/framework/installation)
- [Vite](https://vitejs.dev/guide/)

:::note
While you can still use [Create React App](https://create-react-app.dev), it is not being actively recommended by the React team anymore.
:::

When your project is setup, add the necessary Remotion dependencies:

<Tabs
defaultValue="npm"
values={[
{ label: 'npm', value: 'npm', },
{ label: 'yarn', value: 'yarn', },
{ label: 'pnpm', value: 'pnpm', },
]
}>
<TabItem value="npm">

```bash
npm i remotion @remotion/cli @remotion/player
```

  </TabItem>

  <TabItem value="pnpm">

```bash
pnpm i remotion @remotion/cli @remotion/player
```

  </TabItem>
  <TabItem value="yarn">

```bash
yarn add remotion @remotion/cli @remotion/player
```

  </TabItem>
</Tabs>

Afterwards, create a subfolder for Remotion within your project and add three files: An index file, a `Root.tsx` file for your list of compositions, and a file with your composition. It could look like this:

```diff
 └── src/
+  ├── remotion/
+  │   ├── index.ts
+  │   ├── MyComp.tsx
+  │   └── Root.tsx
   └── app/
       └── App.tsx
```

Your composition (`remotion/MyComp.tsx` in the example) could look for example like this:

```tsx twoslash
export const MyComp: React.FC<{text: string}> = ({text}) => {
  return <div>Hello {text}!</div>;
};
```

Your list of videos (`remotion/Root.tsx` in the example) could look like this:

```tsx twoslash
// @allowUmdGlobalAccess
// @filename: ./MyComp.tsx
export const MyComp = () => <></>;

// @filename: index.tsx
// ---cut---
import {Composition} from 'remotion';
import {MyComp} from './MyComp';

export const MyVideo = () => {
  return (
    <>
      <Composition component={MyComp} durationInFrames={120} width={1920} height={1080} fps={30} id="my-comp" defaultProps={{text: 'World'}} />
    </>
  );
};
```

Your index file (`remotion/index.ts` in the example) could look like this:

```tsx twoslash
// @filename: ./Root.tsx
export const MyVideo: React.FC<{text: string}> = () => <></>;

// ---cut---
import {registerRoot} from 'remotion';
import {MyVideo} from './Video';

registerRoot(MyVideo);
```

:::tip
Don't move these statements together into one file, as you might break hot reloading.
:::

## Using the Remotion Studio

You can open the Remotion Studio using the `npx remotion studio` command:

```bash
npx remotion studio src/remotion/index.ts
```

:::note
Before v4.0, the command was `npx remotion preview`.
:::

We recommend adding a new script into your package.json for easy access:

```diff
  "scripts": {
+    "remotion": "remotion studio src/remotion/index.ts"
  }
```

## Adding `<Player />` to your app

Anywhere in your app, import the [`<Player />`](/docs/player) component and your Composition component.

```tsx twoslash
// @allowUmdGlobalAccess
// @filename: ./remotion/MyComp.tsx
export const MyComp = () => <></>;

// @filename: index.tsx
// ---cut---
import {Player} from '@remotion/player';
import {MyComp} from './remotion/MyComp';

export const App: React.FC = () => {
  return (
    <Player
      component={MyComp}
      inputProps={{text: 'World'}}
      durationInFrames={120}
      compositionWidth={1920}
      compositionHeight={1080}
      fps={30}
      style={{
        width: 1280,
        height: 720,
      }}
      controls
    />
  );
};
```

:::note
Pass your React component directly to the `component` prop. Don't pass the list of compositions.
:::

If everything worked, you can now run your webapp and preview your video.

## Injecting custom controls

Sometimes you want to add custom buttons or menus into the Player's controls bar (for example an ellipsis “More…” menu with actions such as Download, Transcript, or Settings). The Player supports this via the additionalControls prop which lets you inject arbitrary React output into named slots in the control bar.

## Why use additionalControls?

It's a safe, semantically-correct way to add UI to the control bar.
Returned elements are rendered as-is (no extra wrappers), so you won't accidentally produce nested <button> elements.
The API is generic and forward-compatible and provides useful helpers (for example a playerRef) so your custom control can call play, pause, requestFullscreen, seekTo, etc.

:::note
renderFullscreenButton — that prop is intended to replace the fullscreen button icon. If you return multiple <button> elements from renderFullscreenButton, the Player may wrap the return value with a native button element, producing invalid nested buttons. For adding more controls or multi-button menus, use additionalControls instead.
:::

Prop Shape

```ts
type PlayerControlHelpers = {
  playerRef: React.RefObject<PlayerRef | null>;
  isFullscreen: boolean;
  isPlaying: boolean;
  toggle: () => void;
  requestFullscreen: () => void;
  exitFullscreen: () => void;
};

type AdditionalControlsRenderers = {
  start?: (helpers: PlayerControlHelpers) => React.ReactNode;
  end?: (helpers: PlayerControlHelpers) => React.ReactNode;
};
```
:::note
start — renders controls on the left side of the control bar (near play/pause).
end — renders controls on the right side of the control bar (near fullscreen and other action icons).
The helpers let your control interact with the player safely.
:::

Basic Example

```tsx
import React, {useState} from 'react';
import {Player} from '@remotion/player';

export const Example: React.FC = () => {
  const [open, setOpen] = useState(false);

  return (
    <Player
      component={MyComp}
      durationInFrames={120}
      compositionWidth={1280}
      compositionHeight={720}
      fps={30}
      controls
      additionalControls={{
        end: ({ playerRef, isFullscreen }) => (
          <div style={{ position: 'relative', display: 'inline-block' }}>
            <button
              aria-label="More options"
              onClick={() => {
                playerRef.current?.pause();
                setOpen((s) => !s);
              }}
            >
              ⋯
            </button>

            {open && (
              <div
                role="menu"
                style={{ position: 'absolute', bottom: '120%', right: 0 }}
              >
                <button onClick={() => { playerRef.current?.seekTo(0); }}>
                  Restart
                </button>
                <button onClick={() => {
                  if (isFullscreen) playerRef.current?.exitFullscreen();
                  else playerRef.current?.requestFullscreen();
                }}>
                  {isFullscreen ? 'Exit fullscreen' : 'Enter fullscreen'}
                </button>
                <button onClick={() => { /* download transcript */ }}>
                  Download transcript
                </button>
              </div>
            )}
          </div>
        ),
      }}
    />
  );
};
```

Accessibility & best practices

:::note
Always use semantic markup for interactive elements (<button> for actions).
Provide aria-label, aria-expanded, and role="menu"/role="menuitem" where appropriate.
If your menu can overlap the canvas or escape the player's container, consider rendering the menu in a Portal so it is not clipped.
Trap focus when an overlay/menu is open and close on Esc for keyboard accessibility.
Keep visual styling minimal in demos; for production use carefully test contrast and focus outlines.
:::

Notes for maintainers / contributors

:::note
The additionalControls API is intentionally generic — keep it unopinionated and free of extra dependencies (so it stays compatible with lightweight builds).
Tests should cover:
The custom node appears in the DOM when provided
The custom node is rendered as-is (no extra wrapper that would create nested semantic issues)
Helpers work (e.g., calling playerRef.current?.pause() actually pauses in a unit test environment or is callable)
Document the API in examples (as shown above) and highlight the renderFullscreenButton caveat to avoid confusion.
:::

## Creating a bundle for server-side rendering

In any Node.JS context, you can call [`bundle()`](/docs/bundle) to bundle your video using Webpack and to server-side render the video. You need to add `@remotion/bundler` to your package.json for this.

```ts twoslash title="server.tsx"
import path from 'path';
import {bundle} from '@remotion/bundler';

const bundled = await bundle(path.join(process.cwd(), 'src', 'remotion', 'index.ts'));
```

See [Server-side rendering](/docs/ssr) for a full example.

:::tip
When using Lambda, you don't need this, you can use the CLI or [`deploySite()`](/docs/lambda/deploysite) which will bundle the video for you.
:::

## See also

- [`<Player />`](/docs/player)
