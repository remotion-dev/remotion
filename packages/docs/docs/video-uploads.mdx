---
image: /generated/articles-docs-video-uploads.png
id: video-uploads
title: Handling user video uploads
crumb: 'Building video apps'
---

In an app where users can upload videos and edit them, we can create a better user experience by loading the video into a player even before the upload is finished. Good news: This can be done pretty easily!

## Allowing user uploads

We have a component which returns a [`<OffthreadVideo>`](/docs/offthreadvideo) tag that includes an URL as source.

```tsx twoslash title="MyComposition.tsx"
const upload = async (file: File) => {
  return 'https://example.com';
};
// ---cut---
import {AbsoluteFill, OffthreadVideo} from 'remotion';

type VideoProps = {
  videoURL: string;
};

export const MyComponent: React.FC<VideoProps> = ({videoURL}) => {
  return (
    <AbsoluteFill>
      <OffthreadVideo src={videoURL} />
    </AbsoluteFill>
  );
};
```

The video URL will be passed from the Remotion Player to our component.  
Using a `<input type="file">` element, we allow a user upload.  
As soon as a file is fully uploaded to the cloud, the URL will be set and can be used by the component to display the video.

```tsx twoslash title="App.tsx"
import {useCallback} from 'react';
const MyComposition: React.FC<{videoUrl: string | null}> = (URL) => {
  return null;
};
const upload = async (file: File) => {
  return 'https://exampleName.s3.examplesRegion.amazonaws.com';
};

// ---cut---
import {Player} from '@remotion/player';
import {useState} from 'react';

export const RemotionPlayer: React.FC = () => {
  const [videoUrl, setVideoUrl] = useState<string | null>(null);

  const handleChange = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files === null) {
      return;
    }

    const file = event.target.files[0];
    //upload is an example function  & returns a URL when a file is uploaded on the cloud.
    const cloudURL = await upload(file);
    // E.g., cloudURL = https://exampleBucketName.s3.ExampleAwsRegion.amazonaws.com
    setVideoUrl(cloudURL);
  }, []);

  return (
    <div>
      {videoUrl === null ? null : <Player component={MyComposition} durationInFrames={120} compositionWidth={1920} compositionHeight={1080} fps={30} inputProps={{videoUrl}} />}

      <input type="file" onChange={handleChange} />
    </div>
  );
};
```

The implementation of the `upload()` function is provider-specific and we do not show an implementation in this article. We assume it is a function that takes a file, uploads it and returns an URL.

## Optimistic updates

When we start the upload of the file, we can create a blob URL using `URL.createObjectURL()` which can be used to display the local file in a [`<Video>`](/docs/media/video) tag. When the file is done uploading and we get the remote URL, the component shall use remote URL as source.

```tsx twoslash title="App.tsx"
const MyComposition: React.FC<{videoUrl: string}> = ({videoUrl}) => {
  return null;
};

const upload = async (file: File) => {
  return 'https://example.com';
};

// ---cut---
import {Player} from '@remotion/player';
import {useCallback, useState} from 'react';

type VideoState =
  | {
      type: 'empty';
    }
  | {
      type: 'blob' | 'cloud';
      url: string;
    };

export const RemotionPlayer: React.FC = () => {
  const [videoState, setVideoState] = useState<VideoState>({
    type: 'empty',
  });

  const handleChange = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files === null) {
      return;
    }

    const file = event.target.files[0];
    const blobUrl = URL.createObjectURL(file);
    setVideoState({type: 'blob', url: blobUrl});
    const cloudUrl = await upload(file);
    setVideoState({type: 'cloud', url: cloudUrl});
    URL.revokeObjectURL(blobUrl);
  }, []);

  return (
    <div>
      {videoState.type !== 'empty' ? <Player component={MyComposition} durationInFrames={120} compositionWidth={1920} compositionHeight={1080} fps={30} inputProps={{videoUrl: videoState.url}} /> : null}
      <input type="file" onChange={handleChange} />
    </div>
  );
};
```

This will result in the user immediately seeing the video as they drag it into the input field. It is a good practice to call `URL.revokeObjectURL()` after the local video is not used anymore to free up the used memory.

:::note
As soon as possible, replace the `blob:` URL with the real URL.  
Since `blob:` URLs don't support the HTTP `Range` header, video seeking performance is degraded when using `blob:` URLs.
:::

## Validating video compatibility

Before uploading a video, you should validate whether the browser can decode it. This saves bandwidth and provides immediate feedback to the user. The recommended best practice is:

1. Check the video locally using a blob URL with Mediabunny's [canDecode()](/docs/mediabunny/can-decode) function
2. If it can be decoded, upload it to the cloud
3. If it cannot be decoded, either re-encode it with FFmpeg or reject the upload

### Check if video can be decoded

Use the `canDecode()` snippet to validate the video before uploading:

```ts twoslash title="can-decode.ts"
import {ALL_FORMATS, Input, UrlSource} from 'mediabunny';

export const canDecode = async (src: string) => {
  const input = new Input({
    formats: ALL_FORMATS,
    source: new UrlSource(src),
  });

  try {
    await input.getFormat();
  } catch {
    return false;
  }

  const videoTrack = await input.getPrimaryVideoTrack();
  if (videoTrack && !(await videoTrack.canDecode())) {
    return false;
  }

  const audioTrack = await input.getPrimaryAudioTrack();
  if (audioTrack && !(await audioTrack.canDecode())) {
    return false;
  }

  return true;
};
```

### Complete example with validation

This example validates the video locally before uploading, then either uploads it directly or sends it to a re-encoding API endpoint:

```tsx twoslash title="ValidatedUploader.tsx"
const canDecode = async (src: string) => {
  return true;
};
const upload = async (file: File) => {
  return 'https://example.com/video.mp4';
};
const MyComposition: React.FC<{videoUrl: string}> = ({videoUrl}) => {
  return null;
};
// ---cut---
import {Player} from '@remotion/player';
import {useCallback, useState} from 'react';

type UploadState = {type: 'idle'} | {type: 'validating'} | {type: 'uploading'} | {type: 'reencoding'} | {type: 'ready'; url: string} | {type: 'error'; message: string};

export const ValidatedUploader: React.FC = () => {
  const [state, setState] = useState<UploadState>({type: 'idle'});

  const handleUpload = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    try {
      // Check if video can be decoded using blob URL
      setState({type: 'validating'});
      const blobUrl = URL.createObjectURL(file);
      const isCompatible = await canDecode(blobUrl);
      URL.revokeObjectURL(blobUrl);

      if (!isCompatible) {
        // Video needs re-encoding
        setState({type: 'reencoding'});
        const formData = new FormData();
        formData.append('video', file);

        const response = await fetch('/api/reencode-video', {
          method: 'POST',
          body: formData,
        });

        const {url} = await response.json();
        setState({type: 'ready', url});
        return;
      }

      // Video is compatible, upload directly
      setState({type: 'uploading'});

      const url = await upload(file);

      setState({type: 'ready', url});
    } catch (error) {
      setState({type: 'error', message: 'Failed to process video'});
    }
  }, []);

  return (
    <div>
      <input type="file" accept="video/*" onChange={handleUpload} />

      {state.type === 'validating' && <p>Checking compatibility...</p>}
      {state.type === 'uploading' && <p>Uploading...</p>}
      {state.type === 'reencoding' && <p>Re-encoding and uploading...</p>}
      {state.type === 'error' && <p>Error: {state.message}</p>}
      {state.type === 'ready' && <Player component={MyComposition} durationInFrames={120} compositionWidth={1920} compositionHeight={1080} fps={30} inputProps={{videoUrl: state.url}} />}
    </div>
  );
};
```

### Server-side re-encoding API

Create an API endpoint that receives the video, re-encodes it using FFmpeg, and returns the URL:

```ts title="server.ts"
import express from 'express';
import multer from 'multer';
import {execa} from 'execa';
import path from 'path';
import fs from 'fs/promises';

const app = express();
const upload = multer({dest: 'uploads/'});

app.post('/api/reencode-video', upload.single('video'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({error: 'No video file provided'});
  }

  const inputPath = req.file.path;
  const outputPath = path.join('uploads', `reencoded-${Date.now()}.mp4`);

  try {
    await execa('ffmpeg', [
      '-i',
      inputPath,
      '-c:v',
      'libx264', // H.264 video codec (widely supported)
      '-preset',
      'fast',
      '-crf',
      '23',
      '-c:a',
      'aac',
      '-b:a',
      '128k',
      outputPath,
    ]);

    // Upload re-encoded video to cloud storage
    // This is provider-specific (S3, GCS, etc.)
    const cloudUrl = await uploadToCloud(outputPath);

    // Clean up temporary files
    await fs.unlink(inputPath);
    await fs.unlink(outputPath);

    res.json({url: cloudUrl});
  } catch (error) {
    // Clean up on error
    await fs.unlink(inputPath).catch(() => {});
    await fs.unlink(outputPath).catch(() => {});

    res.status(500).json({error: 'Failed to re-encode video'});
  }
});

// Example cloud upload function (implementation depends on your provider)
async function uploadToCloud(filePath: string): Promise<string> {
  // Example using AWS S3:
  // const fileContent = await fs.readFile(filePath);
  // const s3 = new S3Client({region: 'us-east-1'});
  // await s3.send(new PutObjectCommand({
  //   Bucket: 'my-bucket',
  //   Key: `videos/${path.basename(filePath)}`,
  //   Body: fileContent,
  // }));
  // return `https://my-bucket.s3.amazonaws.com/videos/${path.basename(filePath)}`;

  return `https://example.com/videos/${path.basename(filePath)}`;
}

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

The API endpoint:

1. Receives the video file via multipart form data
2. Saves it temporarily using multer
3. Re-encodes it with FFmpeg to H.264/AAC format
4. Uploads the re-encoded video to cloud storage
5. Cleans up temporary files
6. Returns the cloud URL to the client

## See also

- [Uploading with presigned URLs](/docs/presigned-urls)
- [Check if video can be decoded](/docs/mediabunny/can-decode)
- [Mediabunny Documentation](https://mediabunny.dev)
