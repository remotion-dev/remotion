{"version":3,"file":"StringBuilder.js","sourceRoot":"","sources":["../src/StringBuilder.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AA4B3D;;;;;;;;;;;;GAYG;AACH,MAAa,aAAa;IAGxB;QACE,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;IACpB,CAAC;IAED,0CAA0C;IACnC,MAAM,CAAC,IAAY;QACxB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC1B,CAAC;IAED,4CAA4C;IACrC,QAAQ;QACb,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC9B,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC5B,MAAM,MAAM,GAAW,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YAC7C,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;YACxB,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC;QAC3B,CAAC;QAED,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC;CACF;AA1BD,sCA0BC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * An interface for a builder object that allows a large text string to be constructed incrementally by appending\n * small chunks.\n *\n * @remarks\n *\n * {@link StringBuilder} is the default implementation of this contract.\n *\n * @public\n */\nexport interface IStringBuilder {\n  /**\n   * Append the specified text to the buffer.\n   */\n  append(text: string): void;\n\n  /**\n   * Returns a single string containing all the text that was appended to the buffer so far.\n   *\n   * @remarks\n   *\n   * This is a potentially expensive operation.\n   */\n  toString(): string;\n}\n\n/**\n * This class allows a large text string to be constructed incrementally by appending small chunks.  The final\n * string can be obtained by calling StringBuilder.toString().\n *\n * @remarks\n * A naive approach might use the `+=` operator to append strings:  This would have the downside of copying\n * the entire string each time a chunk is appended, resulting in `O(n^2)` bytes of memory being allocated\n * (and later freed by the garbage  collector), and many of the allocations could be very large objects.\n * StringBuilder avoids this overhead by accumulating the chunks in an array, and efficiently joining them\n * when `getText()` is finally called.\n *\n * @public\n */\nexport class StringBuilder implements IStringBuilder {\n  private _chunks: string[];\n\n  public constructor() {\n    this._chunks = [];\n  }\n\n  /** {@inheritDoc IStringBuilder.append} */\n  public append(text: string): void {\n    this._chunks.push(text);\n  }\n\n  /** {@inheritDoc IStringBuilder.toString} */\n  public toString(): string {\n    if (this._chunks.length === 0) {\n      return '';\n    }\n\n    if (this._chunks.length > 1) {\n      const joined: string = this._chunks.join('');\n      this._chunks.length = 1;\n      this._chunks[0] = joined;\n    }\n\n    return this._chunks[0];\n  }\n}\n"]}