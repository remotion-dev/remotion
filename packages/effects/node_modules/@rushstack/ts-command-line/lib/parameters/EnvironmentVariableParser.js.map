{"version":3,"file":"EnvironmentVariableParser.js","sourceRoot":"","sources":["../../src/parameters/EnvironmentVariableParser.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D;;;;;GAKG;AACH,MAAa,yBAAyB;IAC7B,MAAM,CAAC,WAAW,CAAC,UAAkB;QAC1C,MAAM,gBAAgB,GAAuB,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QAErE,IAAI,gBAAgB,KAAK,SAAS,EAAE,CAAC;YACnC,mEAAmE;YACnE,0FAA0F;YAE1F,IAAI,gBAAgB,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;gBAC3C,iGAAiG;gBACjG,2FAA2F;gBAC3F,iGAAiG;gBACjG,+FAA+F;gBAC/F,mGAAmG;gBACnG,+FAA+F;gBAC/F,2BAA2B;gBAC3B,IAAI,CAAC;oBACH,MAAM,UAAU,GAAY,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;oBACzD,IACE,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC;wBAC1B,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,KAAK,QAAQ,IAAI,OAAO,CAAC,KAAK,SAAS,IAAI,OAAO,CAAC,KAAK,QAAQ,CAAC,EAClG,CAAC;wBACD,MAAM,IAAI,KAAK,CACb,OAAO,gBAAgB,6CAA6C;4BAClE,wDAAwD,CAC3D,CAAC;oBACJ,CAAC;oBACD,OAAO,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;gBAC7C,CAAC;gBAAC,OAAO,EAAE,EAAE,CAAC;oBACZ,MAAM,IAAI,KAAK,CACb,OAAO,gBAAgB,qDAAqD;wBAC1E,wBAAwB;wBACvB,EAAY,CAAC,OAAO,CACxB,CAAC;gBACJ,CAAC;YACH,CAAC;iBAAM,CAAC;gBACN,gGAAgG;gBAChG,gCAAgC;gBAChC,OAAO,CAAC,gBAAgB,CAAC,CAAC;YAC5B,CAAC;QACH,CAAC;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;CACF;AA5CD,8DA4CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * Some parameter types can receive their values from an environment variable instead of\n * a command line argument. This class provides some utility methods for parsing environment\n * variable values.\n * @internal\n */\nexport class EnvironmentVariableParser {\n  public static parseAsList(envVarName: string): string[] | undefined {\n    const environmentValue: string | undefined = process.env[envVarName];\n\n    if (environmentValue !== undefined) {\n      // NOTE: If the environment variable is defined as an empty string,\n      // here we will accept the empty string as our value.  (For number/flag we don't do that.)\n\n      if (environmentValue.trimLeft()[0] === '[') {\n        // Specifying multiple items in an environment variable is a somewhat rare case.  But environment\n        // variables are actually a pretty reliable way for a tool to avoid shell escaping problems\n        // when spawning another tool.  For this case, we need a reliable way to pass an array of strings\n        // that could contain any character.  For example, if we simply used \";\" as the list delimiter,\n        // then what to do if a string contains that character?  We'd need to design an escaping mechanism.\n        // Since JSON is simple and standard and can escape every possible string, it's a better option\n        // than a custom delimiter.\n        try {\n          const parsedJson: unknown = JSON.parse(environmentValue);\n          if (\n            !Array.isArray(parsedJson) ||\n            !parsedJson.every((x) => typeof x === 'string' || typeof x === 'boolean' || typeof x === 'number')\n          ) {\n            throw new Error(\n              `The ${environmentValue} environment variable value must be a JSON ` +\n                ` array containing only strings, numbers, and booleans.`\n            );\n          }\n          return parsedJson.map((x) => x.toString());\n        } catch (ex) {\n          throw new Error(\n            `The ${environmentValue} environment variable value looks like a JSON array` +\n              ` but failed to parse: ` +\n              (ex as Error).message\n          );\n        }\n      } else {\n        // As a shorthand, a single value may be specified without JSON encoding, as long as it does not\n        // start with the \"[\" character.\n        return [environmentValue];\n      }\n    }\n\n    return undefined;\n  }\n}\n"]}