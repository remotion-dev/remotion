{"version":3,"file":"AstNamespaceImport.js","sourceRoot":"","sources":["../../src/analyzer/AstNamespaceImport.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAK3D,2CAAiD;AAUjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AACH,MAAa,kBAAmB,SAAQ,8BAAkB;IA6BxD,YAAmB,OAAmC;QACpD,KAAK,EAAE,CAAC;QA7BV;;;WAGG;QACI,aAAQ,GAAY,KAAK,CAAC;QA0B/B,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;QAC3C,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;QACvC,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAC/B,CAAC;IAED,oBAAoB;IACpB,IAAW,SAAS;QAClB,WAAW;QACX,OAAO,IAAI,CAAC,aAAa,CAAC;IAC5B,CAAC;IAEM,wBAAwB,CAAC,SAAoB;QAClD,MAAM,mBAAmB,GAAwB,SAAS,CAAC,cAAc,CAAC,wBAAwB,CAChG,IAAI,CAAC,SAAS,CACf,CAAC;QACF,OAAO,mBAAmB,CAAC;IAC7B,CAAC;CACF;AAjDD,gDAiDC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as ts from 'typescript';\n\nimport type { AstModule, AstModuleExportInfo } from './AstModule';\nimport { AstSyntheticEntity } from './AstEntity';\nimport type { Collector } from '../collector/Collector';\n\nexport interface IAstNamespaceImportOptions {\n  readonly astModule: AstModule;\n  readonly namespaceName: string;\n  readonly declaration: ts.Declaration;\n  readonly symbol: ts.Symbol;\n}\n\n/**\n * `AstNamespaceImport` represents a namespace that is created implicitly by a statement\n * such as `import * as example from \"./file\";`\n *\n * @remarks\n *\n * A typical input looks like this:\n * ```ts\n * // Suppose that example.ts exports two functions f1() and f2().\n * import * as example from \"./file\";\n * export { example };\n * ```\n *\n * API Extractor's .d.ts rollup will transform it into an explicit namespace, like this:\n * ```ts\n * declare f1(): void;\n * declare f2(): void;\n *\n * declare namespace example {\n *   export {\n *     f1,\n *     f2\n *   }\n * }\n * ```\n *\n * The current implementation does not attempt to relocate f1()/f2() to be inside the `namespace`\n * because other type signatures may reference them directly (without using the namespace qualifier).\n * The `declare namespace example` is a synthetic construct represented by `AstNamespaceImport`.\n */\nexport class AstNamespaceImport extends AstSyntheticEntity {\n  /**\n   * Returns true if the AstSymbolTable.analyze() was called for this object.\n   * See that function for details.\n   */\n  public analyzed: boolean = false;\n\n  /**\n   * For example, if the original statement was `import * as example from \"./file\";`\n   * then `astModule` refers to the `./file.d.ts` file.\n   */\n  public readonly astModule: AstModule;\n\n  /**\n   * For example, if the original statement was `import * as example from \"./file\";`\n   * then `namespaceName` would be `example`.\n   */\n  public readonly namespaceName: string;\n\n  /**\n   * The original `ts.SyntaxKind.NamespaceImport` which can be used as a location for error messages.\n   */\n  public readonly declaration: ts.Declaration;\n\n  /**\n   * The original `ts.SymbolFlags.Namespace` symbol.\n   */\n  public readonly symbol: ts.Symbol;\n\n  public constructor(options: IAstNamespaceImportOptions) {\n    super();\n    this.astModule = options.astModule;\n    this.namespaceName = options.namespaceName;\n    this.declaration = options.declaration;\n    this.symbol = options.symbol;\n  }\n\n  /** {@inheritdoc} */\n  public get localName(): string {\n    // abstract\n    return this.namespaceName;\n  }\n\n  public fetchAstModuleExportInfo(collector: Collector): AstModuleExportInfo {\n    const astModuleExportInfo: AstModuleExportInfo = collector.astSymbolTable.fetchAstModuleExportInfo(\n      this.astModule\n    );\n    return astModuleExportInfo;\n  }\n}\n"]}